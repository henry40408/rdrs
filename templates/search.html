{% extends "base.html" %}
{% import "macros.html" as macros %}

{% block html_attrs %}{% call macros::theme_attr(theme) %}{% endcall %}{% endblock %}

{% block title %}Search - RDRS{% endblock %}

{% block flash %}{% call macros::flash(flash_messages) %}{% endcall %}{% endblock %}

{% block content %}
{% call macros::nav("search", is_admin, is_masquerading, username) %}{% endcall %}

<style>
.entries-list-refreshing {
    position: relative;
    opacity: 0.5;
    pointer-events: none;
}
</style>

<h1>Search</h1>

<div class="filter-bar">
    <div class="form-group form-group-inline">
        <label for="filter-search">Query</label>
        <input type="text" id="filter-search" placeholder="Enter search term..."
               style="width:20em;" onkeydown="handleSearchKeydown(event)" autofocus>
    </div>
    <div>
        <button type="button" onclick="loadEntries()">[Search]</button>
    </div>
</div>

<hr>

<div id="entries-list">
    <p class="muted">Enter a search term and press Enter to search.</p>
</div>

<div id="load-more" style="display:none; margin-top:1rem;">
    <button type="button" onclick="loadMore()">[Load More]</button>
</div>

<p id="entries-count" class="muted"></p>

<script>
    let entries = [];
    let currentOffset = 0;
    const limit = {{ entries_per_page }};
    let total = 0;
    let selectedIndex = -1;
    let hasSearched = false;

    async function loadEntries(reset = true) {
        const search = document.getElementById('filter-search').value.trim();
        if (!search) {
            document.getElementById('entries-list').innerHTML = '<p class="muted">Enter a search term and press Enter to search.</p>';
            document.getElementById('entries-count').textContent = '';
            document.getElementById('load-more').style.display = 'none';
            return;
        }

        hasSearched = true;
        const container = document.getElementById('entries-list');

        container.classList.add('entries-list-refreshing');
        if (window.loading) window.loading.start();

        if (reset) {
            currentOffset = 0;
            entries = [];
        }

        const params = new URLSearchParams();
        params.set('limit', limit);
        params.set('offset', currentOffset);
        params.set('search', search);

        const url = `/api/entries?${params.toString()}`;

        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error('Failed to load entries');
            }
            const data = await response.json();

            if (reset) {
                entries = data.entries;
            } else {
                entries = entries.concat(data.entries);
            }
            total = data.total;

            renderEntries();
            updateLoadMoreButton();
            updateEntriesCount();
            updateURL();
        } catch (err) {
            document.getElementById('entries-list').innerHTML = '<p class="muted">[ERROR] Failed to load entries</p>';
        } finally {
            container.classList.remove('entries-list-refreshing');
            if (window.loading) window.loading.stop();
        }
    }

    function renderEntries() {
        const container = document.getElementById('entries-list');
        const search = document.getElementById('filter-search').value.trim();

        if (entries.length === 0) {
            container.innerHTML = '<p class="muted">No entries found.</p>';
            return;
        }

        container.innerHTML = entries.map((entry, index) => {
            const title = decodeHtml(entry.title) || 'Untitled';
            const feedTitle = decodeHtml(entry.feed_title) || entry.feed_url;
            const date = entry.published_at ? formatDate(entry.published_at) : '';
            const dateTitle = entry.published_at ? formatDateTime(entry.published_at) : '';
            const isRead = entry.read_at !== null;
            const isStarred = entry.starred_at !== null;
            const summaryStatus = entry.summary_status;
            const feedIconHtml = entry.feed_has_icon
                ? `<img src="/api/feeds/${entry.feed_id}/icon" alt="" class="feed-icon" onerror="this.style.display='none'">`
                : '';
            const isSelected = index === selectedIndex;
            const titleHtml = search ? highlightText(title, search) : escapeHtml(title);

            let summaryBadgeHtml = '';
            if (summaryStatus === 'completed') {
                summaryBadgeHtml = '<span title="Has Summary" class="summary-badge">[S]</span>';
            } else if (summaryStatus === 'pending') {
                summaryBadgeHtml = '<span title="Pending" class="summary-badge-pending">[P]</span>';
            } else if (summaryStatus === 'processing') {
                summaryBadgeHtml = '<span title="Processing" class="summary-badge-processing">[...]</span>';
            } else if (summaryStatus === 'failed') {
                summaryBadgeHtml = '<span title="Failed" class="summary-badge-failed">[F]</span>';
            }

            let contentSnippetHtml = '';
            if (search && entry.content) {
                const snippet = getContentSnippet(entry.content, search);
                if (snippet) {
                    contentSnippetHtml = `<div class="muted" style="font-size:0.8rem; margin-top:0.4rem; font-style:italic;">${highlightText(snippet, search)}</div>`;
                }
            }

            return `
            <div class="entry-item${isSelected ? ' selected' : ''}" id="entry-${entry.id}" data-index="${index}"${isRead ? ' style="opacity:0.6;"' : ''}>
                <div>
                    <a href="/entries/${entry.id}" class="entry-item-title" style="font-weight:${isRead ? 'normal' : 'bold'};">${titleHtml}</a>
                    ${isStarred ? '<span title="Starred">*</span>' : ''}
                    ${summaryBadgeHtml}
                </div>${contentSnippetHtml}
                <div class="muted entry-item-meta">
                    ${feedIconHtml}<a href="/feeds/${entry.feed_id}/entries">${escapeHtml(feedTitle)}</a> &middot; <a href="/categories/${entry.category_id}/entries">${escapeHtml(entry.category_name)}</a>${date ? ` &middot; <span title="${dateTitle}">${date}</span>` : ''}
                </div>
                <div class="entry-item-actions">
                    ${isRead
                        ? `<a href="#" onclick="markUnread(${entry.id}); return false;">[unread]</a>`
                        : `<a href="#" onclick="markRead(${entry.id}); return false;">[read]</a>`
                    }
                    <a href="#" onclick="toggleStar(${entry.id}); return false;">[${isStarred ? 'unstar' : 'star'}]</a>
                    ${entry.link ? `<a href="${escapeHtml(entry.link)}" target="_blank" rel="noopener noreferrer" onclick="markRead(${entry.id})">[original]</a>` : ''}
                </div>
            </div>
            `;
        }).join('');
    }

    function updateLoadMoreButton() {
        const btn = document.getElementById('load-more');
        if (entries.length < total) {
            btn.style.display = 'block';
        } else {
            btn.style.display = 'none';
        }
    }

    function updateEntriesCount() {
        if (hasSearched) {
            document.getElementById('entries-count').textContent = `Showing ${entries.length} of ${total} entries`;
        }
    }

    function updateURL() {
        const search = document.getElementById('filter-search').value.trim();
        const params = new URLSearchParams();
        if (search) params.set('q', search);
        const newURL = params.toString() ? `/search?${params.toString()}` : '/search';
        history.replaceState(null, '', newURL);
    }

    async function loadMore() {
        currentOffset += limit;
        await loadEntries(false);
    }

    async function markRead(id) {
        try {
            const response = await fetch(`/api/entries/${id}/read`, { method: 'PUT' });
            if (!response.ok) throw new Error('Failed to mark as read');
            const updated = await response.json();
            updateEntryInList(id, updated);
        } catch (err) {
            flash.error(err.message);
        }
    }

    async function markUnread(id) {
        try {
            const response = await fetch(`/api/entries/${id}/unread`, { method: 'PUT' });
            if (!response.ok) throw new Error('Failed to mark as unread');
            const updated = await response.json();
            updateEntryInList(id, updated);
        } catch (err) {
            flash.error(err.message);
        }
    }

    async function toggleStar(id) {
        try {
            const response = await fetch(`/api/entries/${id}/star`, { method: 'PUT' });
            if (!response.ok) throw new Error('Failed to toggle star');
            const updated = await response.json();
            updateEntryInList(id, updated);
        } catch (err) {
            flash.error(err.message);
        }
    }

    function updateEntryInList(id, updated) {
        const idx = entries.findIndex(e => e.id === id);
        if (idx >= 0) {
            entries[idx].read_at = updated.read_at;
            entries[idx].starred_at = updated.starred_at;
            renderEntries();
        }
    }

    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function highlightText(text, search) {
        if (!search || !text) return escapeHtml(text);
        const escaped = escapeHtml(text);
        const searchEscaped = escapeHtml(search);
        const regex = new RegExp(`(${searchEscaped.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
        return escaped.replace(regex, '<span class="search-highlight">$1</span>');
    }

    function getContentSnippet(content, search, maxLen = 80) {
        if (!content || !search) return null;
        const text = content.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
        const lowerText = text.toLowerCase();
        const lowerSearch = search.toLowerCase();
        const idx = lowerText.indexOf(lowerSearch);
        if (idx === -1) return null;

        const contextBefore = 30;
        const start = Math.max(0, idx - contextBefore);
        const end = Math.min(text.length, idx + search.length + (maxLen - contextBefore));
        let snippet = text.substring(start, end);
        if (start > 0) snippet = '...' + snippet;
        if (end < text.length) snippet = snippet + '...';
        return snippet;
    }

    function decodeHtml(html) {
        if (!html) return '';
        const textarea = document.createElement('textarea');
        textarea.innerHTML = html;
        return textarea.value;
    }

    function formatDate(isoString) {
        const date = new Date(isoString);
        return date.toLocaleDateString();
    }

    function formatDateTime(isoString) {
        const date = new Date(isoString);
        return date.toLocaleString();
    }

    function handleSearchKeydown(event) {
        if (event.key === 'Enter') {
            event.preventDefault();
            loadEntries();
        } else if (event.key === 'Escape') {
            event.preventDefault();
            event.target.blur();
        }
    }

    // Keyboard navigation
    function selectEntry(index) {
        if (entries.length === 0) return;

        if (index < 0) index = 0;
        if (index >= entries.length) index = entries.length - 1;

        const prevSelected = document.querySelector('.entry-item.selected');
        if (prevSelected) prevSelected.classList.remove('selected');

        selectedIndex = index;
        const newSelected = document.querySelector(`.entry-item[data-index="${index}"]`);
        if (newSelected) {
            newSelected.classList.add('selected');
            newSelected.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        }
    }

    function getSelectedEntry() {
        if (selectedIndex >= 0 && selectedIndex < entries.length) {
            return entries[selectedIndex];
        }
        return null;
    }

    function findNextUnread(direction) {
        if (entries.length === 0) return -1;

        const start = selectedIndex < 0 ? (direction > 0 ? -1 : entries.length) : selectedIndex;
        let index = start + direction;

        while (index >= 0 && index < entries.length) {
            if (entries[index].read_at === null) {
                return index;
            }
            index += direction;
        }
        return -1;
    }

    function openSelectedEntry() {
        const entry = getSelectedEntry();
        if (entry) {
            window.location.href = `/entries/${entry.id}`;
        }
    }

    function openOriginalLink() {
        const entry = getSelectedEntry();
        if (entry && entry.link) {
            markRead(entry.id);
            window.open(entry.link, '_blank', 'noopener,noreferrer');
        }
    }

    async function toggleSelectedRead() {
        const entry = getSelectedEntry();
        if (entry) {
            if (entry.read_at === null) {
                await markRead(entry.id);
            } else {
                await markUnread(entry.id);
            }
        }
    }

    async function toggleSelectedStar() {
        const entry = getSelectedEntry();
        if (entry) {
            await toggleStar(entry.id);
        }
    }

    window.keyboard.init('list');
    window.keyboard.setHelpItems([
        { key: 'j', desc: 'Next entry' },
        { key: 'k', desc: 'Previous entry' },
        { key: 'g g', desc: 'First entry' },
        { key: 'G', desc: 'Last entry' },
        { key: 'n', desc: 'Next unread entry' },
        { key: 'N', desc: 'Previous unread entry' },
        { key: 'Enter / o', desc: 'Open entry' },
        { key: 'v', desc: 'Open original in new tab' },
        { key: 'm', desc: 'Toggle read/unread' },
        { key: 's', desc: 'Toggle star' },
        { key: 'r', desc: 'Re-run search' },
        { key: '/', desc: 'Focus search box' },
        { key: 'c', desc: 'Go to category page' },
        { key: 'f', desc: 'Go to feed page' },
    ]);
    window.keyboard.registerHandlers({
        handleCombo: function(combo) {
            if (combo === 'g g') {
                selectEntry(0);
                return true;
            }
            return false;
        },
        handleKey: function(key, shiftKey) {
            switch (key) {
                case 'j':
                    selectEntry(selectedIndex + 1);
                    return true;
                case 'k':
                    selectEntry(selectedIndex - 1);
                    return true;
                case 'G':
                    if (entries.length > 0) selectEntry(entries.length - 1);
                    return true;
                case 'n':
                    const nextUnread = findNextUnread(1);
                    if (nextUnread >= 0) selectEntry(nextUnread);
                    return true;
                case 'N':
                    const prevUnread = findNextUnread(-1);
                    if (prevUnread >= 0) selectEntry(prevUnread);
                    return true;
                case 'Enter':
                case 'o':
                    openSelectedEntry();
                    return true;
                case 'v':
                    openOriginalLink();
                    return true;
                case 'm':
                    toggleSelectedRead();
                    return true;
                case 's':
                    toggleSelectedStar();
                    return true;
                case 'r':
                    loadEntries();
                    return true;
                case '/':
                    document.getElementById('filter-search').focus();
                    return true;
                case 'c':
                    const entryC = getSelectedEntry();
                    if (entryC) {
                        window.location.href = `/categories/${entryC.category_id}/entries`;
                    }
                    return true;
                case 'f':
                    const entryF = getSelectedEntry();
                    if (entryF) {
                        window.location.href = `/feeds/${entryF.feed_id}/entries`;
                    }
                    return true;
            }
            return false;
        }
    });

    // Initialize from URL
    (function() {
        const urlParams = new URLSearchParams(window.location.search);
        const query = urlParams.get('q');
        if (query) {
            document.getElementById('filter-search').value = query;
            loadEntries();
        }
    })();
</script>
{% endblock %}
