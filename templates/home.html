{% extends "base.html" %}
{% import "macros.html" as macros %}

{% block title %}Home - RDRS{% endblock %}

{% block flash %}{% call macros::flash(flash_messages) %}{% endblock %}

{% block content %}
{% call macros::nav("home", is_admin, is_masquerading, username) %}

<style>
@media (max-width: 768px) {
    .filter-bar {
        flex-wrap: wrap;
    }
    .filter-bar .form-group-inline {
        width: 100%;
    }
    #filter-sort,
    #filter-category,
    #filter-feed {
        width: 100% !important;
    }
}
</style>

<h1>Home</h1>

<h2>Unread Entries</h2>
<div class="filter-bar">
    <div class="form-group form-group-inline">
        <label for="filter-sort">Sort</label>
        <select id="filter-sort" onchange="handleSortChange()" style="width:8em;">
            <option value="name" selected>Name</option>
            <option value="unread">Unread</option>
        </select>
    </div>
    <div class="form-group form-group-inline">
        <label for="filter-category">Category</label>
        <select id="filter-category" onchange="handleFilterChange('category')" style="width:14em;">
            <option value="">All Categories (0)</option>
        </select>
    </div>
    <div class="form-group form-group-inline">
        <label for="filter-feed">Feed</label>
        <select id="filter-feed" onchange="handleFilterChange('feed')" style="width:14em;">
            <option value="">All Feeds (0)</option>
        </select>
    </div>
    <div class="form-group form-group-inline">
        <label for="mark-read-age">Mark as Read</label>
        <select id="mark-read-age" onchange="markAsRead(this.value); this.selectedIndex=0;">
            <option value="">Select...</option>
            <option value="1">Older than 1 day</option>
            <option value="7">Older than 1 week</option>
            <option value="30">Older than 1 month</option>
            <option value="365">Older than 1 year</option>
            <option value="all">All entries</option>
        </select>
    </div>
    <div>
        <button type="button" onclick="loadEntries()">[Refresh]</button>
    </div>
</div>

<div id="entries-list">
    <p class="muted">Loading...</p>
</div>

<div id="load-more" style="display:none; margin-top:1rem;">
    <button type="button" onclick="loadMore()">[Load More]</button>
</div>

<div id="mark-above-read" style="display:none; margin-top:1rem;">
    <button type="button" onclick="markAboveAsRead()">[Mark Above as Read]</button>
</div>

<p id="entries-count" class="muted"></p>

<script>
    let entries = [];
    let categories = [];
    let feeds = [];
    let unreadStats = { by_feed: {}, by_category: {} };
    let currentOffset = 0;
    const limit = {{ entries_per_page }};
    let total = 0;
    let selectedIndex = -1;

    async function loadCategories() {
        try {
            const response = await fetch('/api/categories');
            if (!response.ok) throw new Error('Failed to load categories');
            categories = await response.json();
            updateCategoryDropdown();
        } catch (err) {
            console.error(err);
        }
    }

    async function loadFeeds() {
        try {
            const response = await fetch('/api/feeds');
            if (!response.ok) throw new Error('Failed to load feeds');
            feeds = await response.json();
            updateFeedDropdown();
        } catch (err) {
            console.error(err);
        }
    }

    async function loadUnreadStats() {
        try {
            const response = await fetch('/api/entries/unread-stats');
            if (!response.ok) throw new Error('Failed to load unread stats');
            unreadStats = await response.json();
            updateCategoryDropdown();
            updateFeedDropdown();
        } catch (err) {
            console.error(err);
        }
    }

    function getCurrentSort() {
        return document.getElementById('filter-sort').value;
    }

    function sortItems(items, nameKey, statsMap, idKey) {
        const sort = getCurrentSort();
        if (sort === 'unread') {
            return [...items].sort((a, b) => {
                const countA = statsMap[a[idKey]] || 0;
                const countB = statsMap[b[idKey]] || 0;
                if (countB !== countA) return countB - countA;
                const nameA = (a[nameKey] || a.url || '').toLowerCase();
                const nameB = (b[nameKey] || b.url || '').toLowerCase();
                return nameA.localeCompare(nameB);
            });
        }
        return [...items].sort((a, b) => {
            const nameA = (a[nameKey] || a.url || '').toLowerCase();
            const nameB = (b[nameKey] || b.url || '').toLowerCase();
            return nameA.localeCompare(nameB);
        });
    }

    function updateCategoryDropdown() {
        const select = document.getElementById('filter-category');
        const currentValue = select.value;
        const feedSelect = document.getElementById('filter-feed');
        const selectedFeedId = feedSelect.value;

        // Determine which categories to show
        let categoriesToShow = categories;
        if (selectedFeedId) {
            // When a feed is selected, only show that feed's category
            const selectedFeed = feeds.find(f => f.id === parseInt(selectedFeedId));
            if (selectedFeed) {
                categoriesToShow = categories.filter(c => c.id === selectedFeed.category_id);
            }
        }

        const totalUnread = Object.values(unreadStats.by_category).reduce((a, b) => a + b, 0);
        const sortedCategories = sortItems(categoriesToShow, 'name', unreadStats.by_category, 'id');

        select.innerHTML = `<option value="">(${totalUnread}) All Categories</option>` +
            sortedCategories.map(cat => {
                const count = unreadStats.by_category[cat.id] || 0;
                return `<option value="${cat.id}">(${count}) ${escapeHtml(cat.name)}</option>`;
            }).join('');
        select.value = currentValue;
    }

    function updateFeedDropdown() {
        const select = document.getElementById('filter-feed');
        const currentValue = select.value;
        const categorySelect = document.getElementById('filter-category');
        const selectedCategoryId = categorySelect.value;

        // Determine which feeds to show
        let feedsToShow = feeds;
        if (selectedCategoryId) {
            // When a category is selected, only show that category's feeds
            feedsToShow = feeds.filter(f => f.category_id === parseInt(selectedCategoryId));
        }

        const totalUnread = Object.values(unreadStats.by_feed).reduce((a, b) => a + b, 0);
        const sortedFeeds = sortItems(feedsToShow, 'title', unreadStats.by_feed, 'id');

        select.innerHTML = `<option value="">(${totalUnread}) All Feeds</option>` +
            sortedFeeds.map(f => {
                const count = unreadStats.by_feed[f.id] || 0;
                return `<option value="${f.id}">(${count}) ${escapeHtml(f.title || f.url)}</option>`;
            }).join('');
        select.value = currentValue;
    }

    function updateURL() {
        const params = new URLSearchParams();
        const sortValue = document.getElementById('filter-sort').value;
        const feedId = document.getElementById('filter-feed').value;
        const categoryId = document.getElementById('filter-category').value;

        if (sortValue && sortValue !== 'name') params.set('sort', sortValue);
        if (feedId) params.set('feed', feedId);
        if (categoryId) params.set('category', categoryId);

        const newURL = params.toString() ? `/?${params.toString()}` : '/';
        history.replaceState(null, '', newURL);
    }

    function handleSortChange() {
        updateURL();
        updateCategoryDropdown();
        updateFeedDropdown();
    }

    function handleFilterChange(source = null) {
        const categorySelect = document.getElementById('filter-category');
        const feedSelect = document.getElementById('filter-feed');

        if (source === 'category') {
            const selectedCategoryId = categorySelect.value;
            const selectedFeedId = feedSelect.value;

            if (!selectedCategoryId) {
                // "All Categories" selected: clear feed and reset category dropdown
                feedSelect.value = '';
                updateCategoryDropdown();
            } else if (selectedFeedId) {
                // Clear feed selection if it doesn't belong to the selected category
                const selectedFeed = feeds.find(f => f.id === parseInt(selectedFeedId));
                if (selectedFeed && selectedFeed.category_id !== parseInt(selectedCategoryId)) {
                    feedSelect.value = '';
                }
            }
            updateFeedDropdown();
        } else if (source === 'feed') {
            // Auto-select the feed's category
            const selectedFeedId = feedSelect.value;
            if (selectedFeedId) {
                const selectedFeed = feeds.find(f => f.id === parseInt(selectedFeedId));
                if (selectedFeed) {
                    categorySelect.value = selectedFeed.category_id;
                }
            }
            updateCategoryDropdown();
            updateFeedDropdown();
        } else {
            updateCategoryDropdown();
            updateFeedDropdown();
        }

        updateURL();
        loadEntries();
    }

    async function loadEntries(reset = true) {
        if (reset) {
            currentOffset = 0;
            entries = [];
        }

        const feedId = document.getElementById('filter-feed').value;
        const categoryId = document.getElementById('filter-category').value;

        let url = `/api/entries?unread_only=true&limit=${limit}&offset=${currentOffset}`;
        if (feedId) url += `&feed_id=${feedId}`;
        if (categoryId) url += `&category_id=${categoryId}`;

        try {
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error('Failed to load entries');
            }
            const data = await response.json();

            if (reset) {
                entries = data.entries;
            } else {
                entries = entries.concat(data.entries);
            }
            total = data.total;

            renderEntries();
            updateLoadMoreButton();
            updateUnreadCount();
            updateEntriesCount();
        } catch (err) {
            document.getElementById('entries-list').innerHTML = '<p class="muted">[ERROR] Failed to load entries</p>';
        }
    }

    function renderEntries() {
        const container = document.getElementById('entries-list');

        if (entries.length === 0) {
            const feedId = document.getElementById('filter-feed').value;
            const categoryId = document.getElementById('filter-category').value;
            const hasFilters = feedId || categoryId;

            let html = '<p class="muted">No unread entries.';
            if (hasFilters) {
                html += ' <a href="#" onclick="resetFilters(); return false;">[reset filters]</a>';
            }
            html += '</p>';
            container.innerHTML = html;
            updateMarkAboveButton();
            return;
        }

        container.innerHTML = entries.map((entry, index) => {
            const title = decodeHtml(entry.title) || 'Untitled';
            const feedTitle = decodeHtml(entry.feed_title) || entry.feed_url;
            const date = entry.published_at ? formatDate(entry.published_at) : '';
            const dateTitle = entry.published_at ? formatDateTime(entry.published_at) : '';
            const isStarred = entry.starred_at !== null;
            const summaryStatus = entry.summary_status;
            const feedIconHtml = entry.feed_has_icon
                ? `<img src="/api/feeds/${entry.feed_id}/icon" alt="" class="feed-icon" onerror="this.style.display='none'">`
                : '';
            const isSelected = index === selectedIndex;

            // Determine summary badge based on status
            let summaryBadgeHtml = '';
            if (summaryStatus === 'completed') {
                summaryBadgeHtml = '<span title="Has Summary" class="summary-badge">[S]</span>';
            } else if (summaryStatus === 'pending') {
                summaryBadgeHtml = '<span title="Pending" class="summary-badge-pending">[P]</span>';
            } else if (summaryStatus === 'processing') {
                summaryBadgeHtml = '<span title="Processing" class="summary-badge-processing">[...]</span>';
            } else if (summaryStatus === 'failed') {
                summaryBadgeHtml = '<span title="Failed" class="summary-badge-failed">[F]</span>';
            }

            return `
            <div class="entry-item${isSelected ? ' selected' : ''}" id="entry-${entry.id}" data-index="${index}">
                <div>
                    <a href="/entries/${entry.id}${getFilterQueryString()}" style="font-weight:bold;">${escapeHtml(title)}</a>
                    ${isStarred ? '<span title="Starred">*</span>' : ''}
                    ${summaryBadgeHtml}
                </div>
                <div class="muted entry-item-meta">
                    ${feedIconHtml}<a href="#" data-feed-id="${entry.feed_id}" data-feed-category-id="${entry.category_id}">${escapeHtml(feedTitle)}</a> &middot; <a href="#" data-category-id="${entry.category_id}">${escapeHtml(entry.category_name)}</a>${date ? ` &middot; <span title="${dateTitle}">${date}</span>` : ''}
                </div>
                <div class="entry-item-actions">
                    <a href="#" onclick="markRead(${entry.id}); return false;">[read]</a>
                    <a href="#" onclick="toggleStar(${entry.id}); return false;">[${isStarred ? 'unstar' : 'star'}]</a>
                    ${entry.link ? `<a href="${escapeHtml(entry.link)}" target="_blank" rel="noopener noreferrer">[original]</a>` : ''}
                </div>
            </div>
            `;
        }).join('');

        updateMarkAboveButton();
    }

    function updateLoadMoreButton() {
        const btn = document.getElementById('load-more');
        if (entries.length < total) {
            btn.style.display = 'block';
        } else {
            btn.style.display = 'none';
        }
    }

    async function loadMore() {
        currentOffset += limit;
        await loadEntries(false);
    }

    async function markRead(id) {
        try {
            const response = await fetch(`/api/entries/${id}/read`, { method: 'PUT' });
            if (!response.ok) {
                throw new Error('Failed to mark as read');
            }
            // Remove from list
            entries = entries.filter(e => e.id !== id);
            total--;
            renderEntries();
            updateLoadMoreButton();
            updateUnreadCount();
            loadUnreadStats();  // Refresh dropdown stats for sorting
        } catch (err) {
            flash.error(err.message);
        }
    }

    async function toggleStar(id) {
        try {
            const response = await fetch(`/api/entries/${id}/star`, { method: 'PUT' });
            if (!response.ok) {
                throw new Error('Failed to toggle star');
            }
            const updated = await response.json();
            // Update in list
            const idx = entries.findIndex(e => e.id === id);
            if (idx >= 0) {
                entries[idx].starred_at = updated.starred_at;
                renderEntries();
            }
        } catch (err) {
            flash.error(err.message);
        }
    }

    async function markAsRead(age) {
        if (!age) return;

        const feedId = document.getElementById('filter-feed').value;
        const categoryId = document.getElementById('filter-category').value;

        const ageLabels = {
            '1': 'older than 1 day',
            '7': 'older than 1 week',
            '30': 'older than 1 month',
            '365': 'older than 1 year',
            'all': 'all'
        };
        const ageLabel = ageLabels[age] || age;

        let scope = '';
        if (feedId) {
            const feedSelect = document.getElementById('filter-feed');
            const feedName = feedSelect.options[feedSelect.selectedIndex].text;
            scope = ` in feed "${feedName}"`;
        } else if (categoryId) {
            const categorySelect = document.getElementById('filter-category');
            const categoryName = categorySelect.options[categorySelect.selectedIndex].text;
            scope = ` in category "${categoryName}"`;
        }

        if (!confirm(`Mark ${ageLabel} entries${scope} as read?`)) {
            return;
        }

        try {
            const body = {};
            if (feedId) {
                body.feed_id = parseInt(feedId);
            } else if (categoryId) {
                body.category_id = parseInt(categoryId);
            }
            if (age !== 'all') {
                body.older_than_days = parseInt(age);
            }

            const response = await fetch('/api/entries/mark-all-read', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });
            if (!response.ok) {
                throw new Error('Failed to mark as read');
            }
            const result = await response.json();
            flash.success(`Marked ${result.marked_count} entries as read.`);
            loadEntries();
            loadUnreadStats();
        } catch (err) {
            flash.error(err.message);
        }
    }

    function updateUnreadCount() {
        const el = document.getElementById('unread-count');
        if (el) el.textContent = total;
    }

    function updateEntriesCount() {
        document.getElementById('entries-count').textContent = `Showing ${entries.length} of ${total} entries`;
    }

    function updateMarkAboveButton() {
        const btn = document.getElementById('mark-above-read');
        if (entries.length > 0) {
            btn.style.display = 'block';
        } else {
            btn.style.display = 'none';
        }
    }

    async function resetFilters() {
        const feedSelect = document.getElementById('filter-feed');
        const categorySelect = document.getElementById('filter-category');

        // Step 1: If feed filter is active, reset it first
        if (feedSelect.value) {
            feedSelect.value = '';
            updateCategoryDropdown();
            updateFeedDropdown();
            updateURL();
            await loadEntries();

            // If still no entries, continue to reset category
            if (entries.length === 0 && categorySelect.value) {
                categorySelect.value = '';
                updateCategoryDropdown();
                updateFeedDropdown();
                updateURL();
                await loadEntries();
            }
        } else if (categorySelect.value) {
            // Step 2: Only category filter is active, reset it
            categorySelect.value = '';
            updateCategoryDropdown();
            updateFeedDropdown();
            updateURL();
            await loadEntries();
        }
    }

    async function markAboveAsRead() {
        if (entries.length === 0) return;

        if (!confirm(`Mark all ${entries.length} loaded entries as read?`)) {
            return;
        }

        const entryIds = entries.map(e => e.id);

        try {
            const response = await fetch('/api/entries/mark-read-by-ids', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ entry_ids: entryIds })
            });
            if (!response.ok) {
                throw new Error('Failed to mark entries as read');
            }
            const result = await response.json();
            flash.success(`Marked ${result.marked_count} entries as read.`);
            loadEntries();
            loadUnreadStats();
        } catch (err) {
            flash.error(err.message);
        }
    }

    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Decode HTML entities (e.g., &#x27; -> ')
    function decodeHtml(html) {
        if (!html) return '';
        const textarea = document.createElement('textarea');
        textarea.innerHTML = html;
        return textarea.value;
    }

    function formatDate(isoString) {
        const date = new Date(isoString);
        return date.toLocaleDateString();
    }

    function formatDateTime(isoString) {
        const date = new Date(isoString);
        return date.toLocaleString();
    }

    function getFilterQueryString() {
        const feedId = document.getElementById('filter-feed').value;
        const categoryId = document.getElementById('filter-category').value;
        const params = new URLSearchParams();
        if (feedId) params.set('feed', feedId);
        if (categoryId) params.set('category', categoryId);
        const str = params.toString();
        return str ? '?' + str : '';
    }

    document.getElementById('entries-list').addEventListener('click', function(e) {
        if (e.target.matches('[data-feed-id]')) {
            e.preventDefault();
            document.getElementById('filter-feed').value = e.target.dataset.feedId;
            document.getElementById('filter-category').value = e.target.dataset.feedCategoryId;
            handleFilterChange('feed');
        }
        if (e.target.matches('[data-category-id]')) {
            e.preventDefault();
            document.getElementById('filter-category').value = e.target.dataset.categoryId;
            document.getElementById('filter-feed').value = '';
            handleFilterChange('category');
        }
    });

    // Keyboard navigation functions
    function selectEntry(index) {
        if (entries.length === 0) return;

        // Clamp index to valid range
        if (index < 0) index = 0;
        if (index >= entries.length) index = entries.length - 1;

        // Update selection
        const prevSelected = document.querySelector('.entry-item.selected');
        if (prevSelected) prevSelected.classList.remove('selected');

        selectedIndex = index;
        const newSelected = document.querySelector(`.entry-item[data-index="${index}"]`);
        if (newSelected) {
            newSelected.classList.add('selected');
            newSelected.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
        }
    }

    function getSelectedEntry() {
        if (selectedIndex >= 0 && selectedIndex < entries.length) {
            return entries[selectedIndex];
        }
        return null;
    }

    function findNextUnread(direction) {
        if (entries.length === 0) return -1;

        // In home page, all entries are unread, so just move in direction
        const start = selectedIndex < 0 ? (direction > 0 ? -1 : entries.length) : selectedIndex;
        let index = start + direction;

        if (index >= 0 && index < entries.length) {
            return index;
        }
        return -1;
    }

    function openSelectedEntry() {
        const entry = getSelectedEntry();
        if (entry) {
            window.location.href = `/entries/${entry.id}${getFilterQueryString()}`;
        }
    }

    function openOriginalLink() {
        const entry = getSelectedEntry();
        if (entry && entry.link) {
            window.open(entry.link, '_blank', 'noopener,noreferrer');
        }
    }

    async function toggleSelectedRead() {
        const entry = getSelectedEntry();
        if (entry) {
            await markRead(entry.id);
            // After marking read, adjust selection
            if (selectedIndex >= entries.length) {
                selectedIndex = entries.length - 1;
            }
            if (entries.length > 0 && selectedIndex >= 0) {
                selectEntry(selectedIndex);
            }
        }
    }

    async function toggleSelectedStar() {
        const entry = getSelectedEntry();
        if (entry) {
            await toggleStar(entry.id);
        }
    }

    // Register keyboard handlers
    window.keyboard.init('list');
    window.keyboard.registerHandlers({
        handleKey: function(key, shiftKey) {
            switch (key) {
                case 'j':
                    selectEntry(selectedIndex + 1);
                    return true;
                case 'k':
                    selectEntry(selectedIndex - 1);
                    return true;
                case 'n':
                    const nextUnread = findNextUnread(1);
                    if (nextUnread >= 0) selectEntry(nextUnread);
                    return true;
                case 'N':
                    const prevUnread = findNextUnread(-1);
                    if (prevUnread >= 0) selectEntry(prevUnread);
                    return true;
                case 'Enter':
                case 'o':
                    openSelectedEntry();
                    return true;
                case 'v':
                    openOriginalLink();
                    return true;
                case 'm':
                    toggleSelectedRead();
                    return true;
                case 's':
                    toggleSelectedStar();
                    return true;
                case 'r':
                    loadEntries();
                    loadUnreadStats();
                    return true;
            }
            return false;
        }
    });

    // Initialize
    Promise.all([loadCategories(), loadFeeds(), loadUnreadStats()]).then(() => {
        const urlParams = new URLSearchParams(window.location.search);
        const sort = urlParams.get('sort');
        const feedId = urlParams.get('feed');
        const categoryId = urlParams.get('category');

        // Restore sort preference
        if (sort === 'unread') {
            document.getElementById('filter-sort').value = 'unread';
        }

        // Restore filter selections with cascade logic
        if (feedId) {
            const selectedFeed = feeds.find(f => f.id === parseInt(feedId));
            if (selectedFeed) {
                document.getElementById('filter-feed').value = feedId;
                document.getElementById('filter-category').value = selectedFeed.category_id;
            }
        } else if (categoryId) {
            document.getElementById('filter-category').value = categoryId;
        }

        // Update dropdowns with cascade filtering
        updateCategoryDropdown();
        updateFeedDropdown();

        loadEntries();
    });
</script>
{% endblock %}
