{% extends "base.html" %}
{% import "macros.html" as macros %}

{% block title %}Entry - RDRS{% endblock %}

{% block flash %}{% call macros::flash(flash_messages) %}{% endblock %}

{% block content %}
{% call macros::nav("entries", is_admin, is_masquerading, username) %}

<div id="entry-container">
    <p class="muted">Loading...</p>
</div>

<script>
    const entryId = {{ entry_id }};
    const hasSaveServices = {{ has_save_services }};
    const hasKagiConfigured = {{ has_kagi_configured }};
    let entryData = null;
    let neighbors = { prev_id: null, next_id: null };
    let unreadNeighbors = { prev_id: null, next_id: null };
    let currentSummary = null;

    async function loadNeighbors() {
        try {
            const response = await fetch(`/api/entries/${entryId}/neighbors`);
            if (response.ok) {
                neighbors = await response.json();
                updateNeighborLinks();
            }
        } catch (err) {
            console.error('Failed to load neighbors:', err);
        }
    }

    async function loadUnreadNeighbors() {
        try {
            const response = await fetch(`/api/entries/${entryId}/neighbors?unread_only=true`);
            if (response.ok) {
                unreadNeighbors = await response.json();
                updateUnreadNeighborLinks();
            }
        } catch (err) {
            console.error('Failed to load unread neighbors:', err);
        }
    }

    function updateNeighborLinks() {
        const prevLinks = [
            document.getElementById('prev-entry-link'),
            document.getElementById('prev-entry-link-bottom')
        ];
        const nextLinks = [
            document.getElementById('next-entry-link'),
            document.getElementById('next-entry-link-bottom')
        ];

        prevLinks.forEach(link => {
            if (link) {
                if (neighbors.prev_id) {
                    link.href = `/entries/${neighbors.prev_id}`;
                    link.classList.remove('disabled');
                } else {
                    link.removeAttribute('href');
                    link.classList.add('disabled');
                }
            }
        });

        nextLinks.forEach(link => {
            if (link) {
                if (neighbors.next_id) {
                    link.href = `/entries/${neighbors.next_id}`;
                    link.classList.remove('disabled');
                } else {
                    link.removeAttribute('href');
                    link.classList.add('disabled');
                }
            }
        });
    }

    function updateUnreadNeighborLinks() {
        const prevUnreadLinks = [
            document.getElementById('prev-unread-link'),
            document.getElementById('prev-unread-link-bottom')
        ];
        const nextUnreadLinks = [
            document.getElementById('next-unread-link'),
            document.getElementById('next-unread-link-bottom')
        ];

        prevUnreadLinks.forEach(link => {
            if (link) {
                if (unreadNeighbors.prev_id) {
                    link.href = `/entries/${unreadNeighbors.prev_id}`;
                    link.classList.remove('disabled');
                } else {
                    link.removeAttribute('href');
                    link.classList.add('disabled');
                }
            }
        });

        nextUnreadLinks.forEach(link => {
            if (link) {
                if (unreadNeighbors.next_id) {
                    link.href = `/entries/${unreadNeighbors.next_id}`;
                    link.classList.remove('disabled');
                } else {
                    link.removeAttribute('href');
                    link.classList.add('disabled');
                }
            }
        });
    }

    function goToPrevEntry() {
        if (neighbors.prev_id) {
            window.location.href = `/entries/${neighbors.prev_id}`;
        }
    }

    function goToNextEntry() {
        if (neighbors.next_id) {
            window.location.href = `/entries/${neighbors.next_id}`;
        }
    }

    function goToPrevUnreadEntry() {
        if (unreadNeighbors.prev_id) {
            window.location.href = `/entries/${unreadNeighbors.prev_id}`;
        }
    }

    function goToNextUnreadEntry() {
        if (unreadNeighbors.next_id) {
            window.location.href = `/entries/${unreadNeighbors.next_id}`;
        }
    }

    async function loadEntry() {
        try {
            const response = await fetch(`/api/entries/${entryId}`);
            if (!response.ok) {
                if (response.status === 404) {
                    document.getElementById('entry-container').innerHTML = '<p class="muted">Entry not found.</p>';
                    return;
                }
                throw new Error('Failed to load entry');
            }
            const data = await response.json();
            entryData = data;
            renderEntry(data);

            // Auto-mark as read
            if (data.read_at === null) {
                await fetch(`/api/entries/${entryId}/read`, { method: 'PUT' });
            }

            // Load neighbors for n/p navigation
            loadNeighbors();
            // Load unread neighbors for N/P navigation
            loadUnreadNeighbors();

            // Load cached summary if exists
            if (data.has_summary) {
                loadCachedSummary();
            }
        } catch (err) {
            document.getElementById('entry-container').innerHTML = '<p class="muted">[ERROR] Failed to load entry</p>';
        }
    }

    async function loadCachedSummary() {
        try {
            const response = await fetch(`/api/entries/${entryId}/summary`);
            if (response.ok) {
                const data = await response.json();
                if (data.status === 'completed' && data.summary_text) {
                    currentSummary = data.summary_text;
                    showSummary(data.summary_text);
                }
            }
        } catch (err) {
            console.error('Failed to load cached summary:', err);
        }
    }

    function renderEntry(data) {
        const title = decodeHtml(data.title) || 'Untitled';
        const feedTitle = decodeHtml(data.feed_title) || data.feed_url;
        const author = decodeHtml(data.author) || '';
        const date = data.published_at ? new Date(data.published_at).toLocaleString() : '';
        const isStarred = data.starred_at !== null;
        const content = data.sanitized_content || data.summary || '<p class="muted">No content available.</p>';
        const feedIconHtml = data.feed_has_icon
            ? `<img src="/api/feeds/${data.feed_id}/icon" alt="" class="feed-icon" onerror="this.style.display='none'">`
            : '';

        document.getElementById('entry-container').innerHTML = `
            <div class="entry-nav">
                <a href="/entries">&larr; Back to Entries</a>
                <span class="entry-nav-sep">&middot;</span>
                <a href="#" id="prev-entry-link" class="disabled">&larr; Previous</a>
                <span class="entry-nav-sep">&middot;</span>
                <a href="#" id="prev-unread-link" class="disabled">&larr; Previous Unread</a>
                <span class="entry-nav-sep">&middot;</span>
                <a href="#" id="next-unread-link" class="disabled">Next Unread &rarr;</a>
                <span class="entry-nav-sep">&middot;</span>
                <a href="#" id="next-entry-link" class="disabled">Next &rarr;</a>
            </div>

            <h1 class="entry-title">${escapeHtml(title)}</h1>

            <div class="entry-meta">
                ${feedIconHtml}<span>${escapeHtml(feedTitle)}</span>
                ${author ? ` &middot; <span>${escapeHtml(author)}</span>` : ''}
                ${date ? ` &middot; <span>${date}</span>` : ''}
            </div>

            <div class="entry-actions">
                <button type="button" onclick="toggleStar()" id="star-btn">[${isStarred ? 'Unstar' : 'Star'}]</button>
                <button type="button" onclick="markUnread()">[Mark Unread]</button>
                ${data.link ? `<button type="button" onclick="fetchFullContent()" id="fetch-content-btn">[Fetch Full Content]</button>` : ''}
                ${hasKagiConfigured && data.link ? `<button type="button" onclick="summarizeEntry()" id="summarize-btn">[Summarize]</button>` : ''}
                ${hasSaveServices && data.link ? `<button type="button" onclick="saveEntry()" id="save-btn">[Save]</button>` : ''}
                ${data.link ? `<a href="${escapeHtml(data.link)}" target="_blank" rel="noopener noreferrer" class="btn">[View Original]</a>` : ''}
            </div>

            <div id="summary-container" style="display: none;">
                <div class="summary-box">
                    <div class="summary-actions">
                        <button type="button" onclick="copySummary()" id="copy-summary-btn">[Copy]</button>
                        <button type="button" onclick="dismissSummary()">[Dismiss]</button>
                    </div>
                    <blockquote id="summary-content"></blockquote>
                </div>
            </div>

            <hr>

            <article class="entry-content">
                ${content}
            </article>

            <hr>

            <div class="entry-nav entry-nav-bottom">
                <a href="#" id="prev-entry-link-bottom" class="disabled">&larr; Previous</a>
                <span class="entry-nav-sep">&middot;</span>
                <a href="#" id="prev-unread-link-bottom" class="disabled">&larr; Previous Unread</a>
                <span class="entry-nav-sep">&middot;</span>
                <a href="/entries">Back to Entries</a>
                <span class="entry-nav-sep">&middot;</span>
                <a href="#" id="next-unread-link-bottom" class="disabled">Next Unread &rarr;</a>
                <span class="entry-nav-sep">&middot;</span>
                <a href="#" id="next-entry-link-bottom" class="disabled">Next &rarr;</a>
            </div>
        `;
    }

    async function toggleStar() {
        try {
            const response = await fetch(`/api/entries/${entryId}/star`, { method: 'PUT' });
            if (!response.ok) throw new Error('Failed to toggle star');
            const updated = await response.json();
            const btn = document.getElementById('star-btn');
            btn.textContent = updated.starred_at ? '[Unstar]' : '[Star]';
        } catch (err) {
            flash.error(err.message);
        }
    }

    async function markUnread() {
        try {
            const response = await fetch(`/api/entries/${entryId}/unread`, { method: 'PUT' });
            if (!response.ok) throw new Error('Failed to mark as unread');
            flash.success('Marked as unread.');
        } catch (err) {
            flash.error(err.message);
        }
    }

    let summaryPollInterval = null;

    async function summarizeEntry() {
        const btn = document.getElementById('summarize-btn');
        if (!btn) return;

        btn.textContent = '[Summarizing...]';
        btn.disabled = true;

        try {
            const response = await fetch(`/api/entries/${entryId}/summarize`, {
                method: 'POST'
            });

            const data = await response.json();

            if (!response.ok) {
                throw new Error(data.error || 'Failed to summarize');
            }

            // Handle async response based on status
            if (data.status === 'completed' && data.summary_text) {
                // Already cached
                currentSummary = data.summary_text;
                showSummary(data.summary_text);
                btn.textContent = '[Summarize]';
                btn.disabled = false;
            } else if (data.status === 'pending' || data.status === 'processing') {
                // Start polling
                startSummaryPolling();
            } else if (data.status === 'failed') {
                throw new Error(data.error || 'Summarization failed');
            } else {
                throw new Error('Unknown response status');
            }
        } catch (err) {
            flash.error(err.message);
            btn.textContent = '[Summarize]';
            btn.disabled = false;
        }
    }

    function startSummaryPolling() {
        if (summaryPollInterval) return;

        summaryPollInterval = setInterval(async () => {
            try {
                const response = await fetch(`/api/entries/${entryId}/summary`);

                if (response.status === 404) {
                    // Summary was cleared
                    stopSummaryPolling();
                    const btn = document.getElementById('summarize-btn');
                    if (btn) {
                        btn.textContent = '[Summarize]';
                        btn.disabled = false;
                    }
                    return;
                }

                if (!response.ok) {
                    throw new Error('Failed to check summary status');
                }

                const data = await response.json();

                if (data.status === 'completed' && data.summary_text) {
                    stopSummaryPolling();
                    currentSummary = data.summary_text;
                    showSummary(data.summary_text);
                    const btn = document.getElementById('summarize-btn');
                    if (btn) {
                        btn.textContent = '[Summarize]';
                        btn.disabled = false;
                    }
                } else if (data.status === 'failed') {
                    stopSummaryPolling();
                    flash.error(data.error || 'Summarization failed');
                    const btn = document.getElementById('summarize-btn');
                    if (btn) {
                        btn.textContent = '[Summarize]';
                        btn.disabled = false;
                    }
                }
                // Keep polling if still pending or processing
            } catch (err) {
                stopSummaryPolling();
                flash.error(err.message);
                const btn = document.getElementById('summarize-btn');
                if (btn) {
                    btn.textContent = '[Summarize]';
                    btn.disabled = false;
                }
            }
        }, 2000); // Poll every 2 seconds
    }

    function stopSummaryPolling() {
        if (summaryPollInterval) {
            clearInterval(summaryPollInterval);
            summaryPollInterval = null;
        }
    }

    function showSummary(summaryText) {
        const container = document.getElementById('summary-container');
        const content = document.getElementById('summary-content');
        if (container && content && entryData) {
            const cleanTitle = sanitizeTitleForTiddlyWiki(decodeHtml(entryData.title) || 'Untitled');
            const link = entryData.link || '';
            const formattedText = `${cleanTitle}\n\n${link}\n\n${summaryText}`;
            content.textContent = formattedText;
            container.style.display = 'block';
        }
    }

    async function dismissSummary() {
        const container = document.getElementById('summary-container');
        if (container) {
            container.style.display = 'none';
        }
        currentSummary = null;

        // Delete summary from cache
        try {
            await fetch(`/api/entries/${entryId}/summary`, {
                method: 'DELETE'
            });
        } catch (err) {
            console.error('Failed to delete summary from cache:', err);
        }
    }

    function sanitizeTitleForTiddlyWiki(title) {
        if (!title) return '';
        // Remove characters that TiddlyWiki doesn't support
        return title
            .replace(/\[\[/g, '')  // Double brackets (links)
            .replace(/\]\]/g, '')
            .replace(/\[/g, '')    // Single brackets
            .replace(/\]/g, '')
            .replace(/\|/g, '')    // Pipe (link separator)
            .replace(/\{/g, '')    // Curly braces (macros)
            .replace(/\}/g, '')
            .replace(/</g, '')     // Angle brackets (HTML)
            .replace(/>/g, '')
            .trim();
    }

    async function copySummary() {
        if (!currentSummary || !entryData) return;

        const cleanTitle = sanitizeTitleForTiddlyWiki(decodeHtml(entryData.title) || 'Untitled');
        const link = entryData.link || '';

        const formattedText = `${cleanTitle}\n\n${link}\n\n${currentSummary}`;

        try {
            await navigator.clipboard.writeText(formattedText);
            const btn = document.getElementById('copy-summary-btn');
            if (btn) {
                btn.textContent = '[Copied!]';
                setTimeout(() => {
                    btn.textContent = '[Copy]';
                }, 2000);
            }
        } catch (err) {
            flash.error('Failed to copy to clipboard');
        }
    }

    async function saveEntry() {
        const btn = document.getElementById('save-btn');
        if (!btn) return;

        btn.textContent = '[Saving...]';
        btn.disabled = true;

        try {
            const response = await fetch(`/api/entries/${entryId}/save`, {
                method: 'POST'
            });

            const data = await response.json();

            if (!response.ok) {
                throw new Error(data.error || 'Failed to save');
            }

            if (data.all_success) {
                const count = data.results.length;
                flash.success(`Saved to ${count} service${count > 1 ? 's' : ''}`);
                btn.textContent = '[Saved!]';
                // Reset button after a delay
                setTimeout(() => {
                    btn.textContent = '[Save]';
                }, 2000);
            } else {
                // Partial success or all failed
                const failed = data.results.filter(r => !r.success);
                const succeeded = data.results.filter(r => r.success);

                if (succeeded.length > 0) {
                    flash.success(`Saved to: ${succeeded.map(r => r.service).join(', ')}`);
                }
                if (failed.length > 0) {
                    flash.error(`Failed: ${failed.map(r => `${r.service} (${r.message})`).join(', ')}`);
                }
                btn.textContent = '[Save]';
            }
        } catch (err) {
            flash.error(err.message);
            btn.textContent = '[Save]';
        } finally {
            btn.disabled = false;
        }
    }

    let showingFullContent = false;
    let originalContent = null;
    let fullContent = null;

    async function fetchFullContent() {
        const btn = document.getElementById('fetch-content-btn');
        btn.textContent = '[Fetching...]';
        btn.disabled = true;

        try {
            const response = await fetch(`/api/entries/${entryId}/fetch-full-content`, {
                method: 'POST'
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Failed to fetch content');
            }

            const data = await response.json();

            // Save original content (first time only)
            if (!originalContent) {
                originalContent = document.querySelector('.entry-content').innerHTML;
            }

            // Save full content for toggling
            fullContent = data.sanitized_content || '<p class="muted">No content extracted.</p>';

            // Display full content
            document.querySelector('.entry-content').innerHTML = fullContent;

            showingFullContent = true;
            btn.style.display = 'none';

            // Add toggle button if not exists
            if (!document.getElementById('toggle-content-btn')) {
                btn.insertAdjacentHTML('afterend',
                    ' <button type="button" onclick="toggleContent()" id="toggle-content-btn">[Show Original]</button>');
            } else {
                document.getElementById('toggle-content-btn').textContent = '[Show Original]';
            }
        } catch (err) {
            flash.error(err.message);
            btn.textContent = '[Fetch Full Content]';
        } finally {
            btn.disabled = false;
        }
    }

    function toggleContent() {
        const contentEl = document.querySelector('.entry-content');
        const toggleBtn = document.getElementById('toggle-content-btn');

        if (showingFullContent) {
            contentEl.innerHTML = originalContent;
            toggleBtn.textContent = '[Show Full Content]';
        } else {
            contentEl.innerHTML = fullContent;
            toggleBtn.textContent = '[Show Original]';
        }
        showingFullContent = !showingFullContent;
    }

    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Decode HTML entities (e.g., &#x27; -> ')
    function decodeHtml(html) {
        if (!html) return '';
        const textarea = document.createElement('textarea');
        textarea.innerHTML = html;
        return textarea.value;
    }

    // Keyboard navigation functions
    function scrollContent(direction) {
        const scrollAmount = window.innerHeight * 0.4;
        window.scrollBy({
            top: direction * scrollAmount,
            behavior: 'smooth'
        });
    }

    function goBackToList() {
        window.location.href = '/entries';
    }

    function openOriginalLink() {
        if (entryData && entryData.link) {
            window.open(entryData.link, '_blank', 'noopener,noreferrer');
        }
    }

    // Register keyboard handlers
    window.keyboard.init('entry');
    window.keyboard.registerHandlers({
        handleKey: function(key, shiftKey) {
            switch (key) {
                case 'j':
                    scrollContent(1);
                    return true;
                case 'k':
                    scrollContent(-1);
                    return true;
                case 'n':
                    goToNextEntry();
                    return true;
                case 'N':
                    goToNextUnreadEntry();
                    return true;
                case 'p':
                    goToPrevEntry();
                    return true;
                case 'P':
                    goToPrevUnreadEntry();
                    return true;
                case 'u':
                    markUnread();
                    return true;
                case 's':
                    toggleStar();
                    return true;
                case 'v':
                    openOriginalLink();
                    return true;
                case 'f':
                    // If full content already fetched, toggle between original and full
                    if (fullContent) {
                        toggleContent();
                    } else {
                        // Otherwise fetch full content
                        const fetchBtn = document.getElementById('fetch-content-btn');
                        if (fetchBtn && !fetchBtn.disabled) {
                            fetchFullContent();
                        }
                    }
                    return true;
                case 'b':
                    // Save to bookmark services
                    if (hasSaveServices && entryData && entryData.link) {
                        const saveBtn = document.getElementById('save-btn');
                        if (saveBtn && !saveBtn.disabled) {
                            saveEntry();
                        }
                    }
                    return true;
                case 'z':
                    // Summarize with Kagi
                    if (hasKagiConfigured && entryData && entryData.link) {
                        const summarizeBtn = document.getElementById('summarize-btn');
                        if (summarizeBtn && !summarizeBtn.disabled) {
                            summarizeEntry();
                        }
                    }
                    return true;
                case 'Escape':
                case 'q':
                    goBackToList();
                    return true;
            }
            return false;
        }
    });

    // Initialize
    loadEntry();
</script>

<style>
    .entry-title {
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.3;
        margin-bottom: var(--space-3);
        color: #111;
    }

    .entry-meta {
        color: #666;
        margin-bottom: var(--space-5);
        font-size: 0.9rem;
    }

    .entry-actions {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-2);
        margin-bottom: var(--space-6);
    }

    .entry-actions button,
    .entry-actions .btn {
        white-space: nowrap;
    }

    .entry-nav {
        margin-bottom: var(--space-5);
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-2);
        align-items: center;
    }

    .entry-nav-bottom {
        margin-bottom: 0;
        margin-top: var(--space-5);
    }

    .entry-nav-sep {
        color: #999;
    }

    .entry-nav a.disabled {
        color: #ccc;
        pointer-events: none;
        cursor: default;
    }

    .entry-nav a.disabled:hover {
        background: none;
        color: #ccc;
    }

    .entry-content {
        max-width: 720px;
        font-family: Georgia, "Times New Roman", serif;
        font-size: 1.125rem;
        line-height: 1.8;
        color: #222;
    }

    .entry-content p {
        margin-bottom: var(--space-6);
        word-break: break-word;
    }

    .entry-content h1,
    .entry-content h2,
    .entry-content h3,
    .entry-content h4,
    .entry-content h5,
    .entry-content h6 {
        font-family: "SF Mono", "Monaco", "Inconsolata", monospace;
        margin-top: var(--space-8);
        margin-bottom: var(--space-4);
        line-height: 1.3;
        color: #111;
    }

    .entry-content h1 { font-size: 1.5rem; }
    .entry-content h2 { font-size: 1.35rem; }
    .entry-content h3 { font-size: 1.2rem; }
    .entry-content h4 { font-size: 1.1rem; }

    .entry-content a {
        color: #0066cc;
        text-decoration: underline;
        text-underline-offset: 2px;
    }

    .entry-content a:hover {
        background: #0066cc;
        color: #fff;
    }

    .entry-content img {
        max-width: 100%;
        height: auto;
        display: block;
        margin: var(--space-6) auto;
        border-radius: 4px;
    }

    .entry-content figure {
        margin: var(--space-8) 0;
    }

    .entry-content figcaption {
        text-align: center;
        font-size: 0.9rem;
        color: #666;
        margin-top: var(--space-2);
        font-style: italic;
    }

    .entry-content pre {
        overflow-x: auto;
        background: #f8f8f8;
        border: 1px solid #e0e0e0;
        border-radius: 4px;
        padding: var(--space-4);
        margin: var(--space-6) 0;
        font-family: "SF Mono", "Monaco", "Inconsolata", monospace;
        font-size: 0.9rem;
        line-height: 1.5;
    }

    .entry-content code {
        font-family: "SF Mono", "Monaco", "Inconsolata", monospace;
        font-size: 0.9em;
        background: #f0f0f0;
        padding: 0.15em 0.4em;
        border-radius: 3px;
    }

    .entry-content pre code {
        background: none;
        padding: 0;
        font-size: inherit;
    }

    .entry-content blockquote {
        border-left: 4px solid #ddd;
        margin: var(--space-6) 0;
        padding: var(--space-2) 0 var(--space-2) var(--space-6);
        color: #555;
        font-style: italic;
        background: #fafafa;
    }

    .entry-content blockquote p:last-child {
        margin-bottom: 0;
    }

    .entry-content ul,
    .entry-content ol {
        margin: var(--space-6) 0;
        padding-left: var(--space-8);
    }

    .entry-content li {
        margin-bottom: var(--space-2);
    }

    .entry-content li > ul,
    .entry-content li > ol {
        margin: var(--space-2) 0;
    }

    .entry-content table {
        width: 100%;
        border-collapse: collapse;
        margin: var(--space-6) 0;
        font-size: 0.95rem;
    }

    .entry-content th,
    .entry-content td {
        border: 1px solid #ddd;
        padding: 0.75em;
        text-align: left;
    }

    .entry-content th {
        background: #f5f5f5;
        font-weight: bold;
    }

    .entry-content tr:nth-child(even) {
        background: #fafafa;
    }

    .entry-content hr {
        border: none;
        border-top: 1px solid #ddd;
        margin: var(--space-8) 0;
    }

    .entry-content strong,
    .entry-content b {
        font-weight: 600;
    }

    .entry-content em,
    .entry-content i {
        font-style: italic;
    }

    /* Summary box styles */
    #summary-container {
        margin-bottom: var(--space-6);
    }

    .summary-box {
        background: #f8f9fa;
        border: 1px solid #e0e0e0;
        border-radius: 4px;
        padding: var(--space-4);
    }

    .summary-actions {
        display: flex;
        gap: var(--space-2);
        margin-bottom: var(--space-3);
    }

    .summary-box blockquote {
        border-left: 4px solid #0066cc;
        margin: 0;
        padding: var(--space-2) 0 var(--space-2) var(--space-4);
        color: #333;
        font-style: normal;
        background: transparent;
        font-family: Georgia, "Times New Roman", serif;
        font-size: 1rem;
        line-height: 1.6;
        white-space: pre-wrap;
    }
</style>
{% endblock %}
